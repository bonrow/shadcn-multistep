{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "multistep",
  "type": "registry:block",
  "title": "Hello World",
  "description": "A simple hello world component.",
  "dependencies": [
    "zod@4.0.0",
    "react-hook-form@^7.65.0"
  ],
  "registryDependencies": [
    "button",
    "form"
  ],
  "files": [
    {
      "path": "./src/registry/new-york/multi-stepper/multi-stepper.tsx",
      "content": "import { zodResolver } from \"@hookform/resolvers/zod\";\r\nimport { ArrowLeftIcon, ArrowRightIcon } from \"lucide-react\";\r\nimport { AnimatePresence, motion } from \"motion/react\";\r\nimport React from \"react\";\r\nimport { type FieldValues, useForm } from \"react-hook-form\";\r\nimport type { z } from \"zod\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Form } from \"@/components/ui/form\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport {\r\n  MultiStepperPartProvider,\r\n  MultiStepperProvider,\r\n  useMultiStepper,\r\n  useMultiStepperPart,\r\n} from \"./multi-stepper.context\";\r\nimport { ObservableMultiStepperControls } from \"./multi-stepper.controls\";\r\n\r\n//! You should move these type helpers to a separate file if you plan to reuse them\r\n// biome-ignore lint/suspicious/noExplicitAny: needed for type helper\r\ntype UnionKeys<U> = U extends any ? keyof U : never;\r\ntype MergeUnionToObject<U> = {\r\n  [K in UnionKeys<U>]: K extends keyof U ? U[K] : never;\r\n};\r\n\r\n// biome-ignore lint/suspicious/noExplicitAny: not needed\r\ntype FormSchema = z.ZodType<any, FieldValues>;\r\n\r\n/** Readonly array with readonly parts (useful for freezed constants). */\r\nexport type MultiStepPartArray = ReadonlyArray<Readonly<MultiStepPart>>;\r\n\r\n/** Extracts a union of all the IDs in `TPart`. */\r\nexport type MultiStep<TParts extends MultiStepPartArray> = TParts[number][\"id\"];\r\n\r\n/** Infers the `formData` of `TStep` in `TParts`, or returns `never`. */\r\nexport type InferMultiStepFormData<\r\n  TParts extends MultiStepPartArray,\r\n  TStep extends MultiStep<TParts>\r\n> = z.infer<Extract<TParts[number], { id: TStep }>[\"formData\"]>;\r\n\r\n/** Data representation of a single **part** in a multi-stepper. */\r\nexport type MultiStepPart<TFormData extends FormSchema = FormSchema> = {\r\n  id: string;\r\n  title: React.ReactNode;\r\n  formData: TFormData;\r\n  render: React.FC<ReturnType<typeof useForm<z.infer<TFormData>>>>;\r\n};\r\n\r\n/** Extracts the merged result of all steps through forming an intersection. */\r\nexport type MultiStepMergedResult<TParts extends MultiStepPartArray> =\r\n  MergeUnionToObject<z.infer<TParts[number][\"formData\"]>>;\r\n\r\nexport type MultiStepperResult<TParts extends MultiStepPartArray> = {\r\n  merged: MultiStepMergedResult<TParts>;\r\n  parts: {\r\n    [K in MultiStep<TParts>]: InferMultiStepFormData<TParts, K>;\r\n  };\r\n};\r\n\r\n/** Type helper to define a multi step part with proper generics. */\r\nexport const defineMultiStepPart = <TFormData extends FormSchema>(\r\n  part: MultiStepPart<TFormData>\r\n): MultiStepPart<TFormData> => part;\r\n\r\n/** [Framer Motion] used to animate the multi-step form */\r\nconst slideVariants = Object.freeze({\r\n  enter: (direction: number) => ({\r\n    position: \"absolute\",\r\n    x: direction > 0 ? \"100%\" : \"-100%\",\r\n    opacity: 0,\r\n  }),\r\n  center: {\r\n    position: \"relative\",\r\n    x: 0,\r\n    opacity: 1,\r\n    transition: { duration: 0.3 },\r\n  },\r\n  exit: (direction: number) => ({\r\n    position: \"absolute\",\r\n    x: direction < 0 ? \"100%\" : \"-100%\",\r\n    opacity: 0,\r\n    transition: { duration: 0.3 },\r\n  }),\r\n});\r\n\r\nexport function MultiStepper<TParts extends MultiStepPartArray>({\r\n  parts,\r\n  step,\r\n  defaultStep = parts[0]?.id,\r\n  onStepChange,\r\n  onFinish,\r\n  className,\r\n  ...restProps\r\n}: React.ComponentProps<\"div\"> & {\r\n  parts: TParts;\r\n  defaultStep?: MultiStep<TParts>;\r\n  step?: MultiStep<TParts>;\r\n  onStepChange?: (step: MultiStep<TParts>) => void;\r\n  onFinish?: (data: MultiStepperResult<TParts>) => void;\r\n}) {\r\n  const directionRef = React.useRef(0);\r\n  const [_step, _setStep] = React.useState(defaultStep);\r\n  const resultRef = React.useRef<Partial<MultiStepperResult<TParts>>>({});\r\n\r\n  if (_step == null) throw new Error(\"MultiStepper requires at least one step\");\r\n\r\n  const onFinishRef = React.useRef(onFinish);\r\n  onFinishRef.current = onFinish;\r\n\r\n  const onStepChangeRef = React.useRef(onStepChange);\r\n  onStepChangeRef.current = onStepChange;\r\n\r\n  React.useEffect(() => {\r\n    if (step === undefined) return;\r\n    _setStep(step);\r\n  }, [step]);\r\n\r\n  const controls = React.useMemo(() => {\r\n    return new ObservableMultiStepperControls<TParts>({\r\n      parts,\r\n      step: _step,\r\n      onFinish() {\r\n        onFinishRef.current?.(resultRef.current as MultiStepperResult<TParts>);\r\n      },\r\n      onStepChange(newStep) {\r\n        const currentIndex = this.index();\r\n        const newIndex = this.parts.findIndex((p) => p.id === newStep);\r\n        if (newIndex === -1) throw new Error(\"Step not found in parts\");\r\n        directionRef.current = newIndex > currentIndex ? 1 : -1;\r\n        _setStep(newStep);\r\n        onStepChangeRef.current?.(newStep);\r\n      },\r\n    });\r\n  }, [parts, _step]);\r\n\r\n  return (\r\n    <MultiStepperProvider\r\n      value={{\r\n        parts,\r\n        step: _step,\r\n        direction: directionRef.current,\r\n        controls,\r\n        onComplete(data) {\r\n          const p = (resultRef.current.parts ??\r\n            {}) as MultiStepperResult<TParts>[\"parts\"];\r\n          p[_step] = data;\r\n          resultRef.current.parts = p as MultiStepperResult<TParts>[\"parts\"];\r\n          resultRef.current.merged = {\r\n            ...resultRef.current.merged,\r\n            ...data,\r\n          };\r\n          //* Remove this if you don't want to auto-complete on last step submission\r\n          controls.next();\r\n        },\r\n      }}\r\n    >\r\n      <section\r\n        className={cn(\r\n          \"flex flex-col gap-6 overflow-hidden relative\",\r\n          className\r\n        )}\r\n        {...restProps}\r\n      />\r\n    </MultiStepperProvider>\r\n  );\r\n}\r\n\r\nexport function MultiStepperRenderer() {\r\n  const multiStep = useMultiStepper();\r\n  const part = multiStep.controls.part();\r\n\r\n  const form = useForm({ resolver: zodResolver(part.formData) });\r\n\r\n  return (\r\n    <AnimatePresence custom={multiStep.direction}>\r\n      {multiStep.parts.map((part) =>\r\n        part.id === multiStep.controls.step ? (\r\n          <MultiStepPart parts={multiStep.parts} step={part.id} key={part.id}>\r\n            <part.render {...form} />\r\n          </MultiStepPart>\r\n        ) : null\r\n      )}\r\n    </AnimatePresence>\r\n  );\r\n}\r\n\r\nexport function MultiStepPart<\r\n  TParts extends MultiStepPartArray,\r\n  TStep extends MultiStep<TParts>\r\n>({\r\n  parts,\r\n  step,\r\n  children,\r\n  ...restProps\r\n}: React.ComponentProps<typeof motion.div> & {\r\n  parts: TParts;\r\n  step: TStep;\r\n}) {\r\n  const multiStep = useMultiStepper();\r\n\r\n  const part = parts.find((s) => s.id === step);\r\n  if (!part) throw new Error(`Step with id \"${step}\" does not exist.`);\r\n\r\n  return (\r\n    <MultiStepperPartProvider value={part}>\r\n      <motion.div\r\n        key={part.id}\r\n        variants={slideVariants}\r\n        initial=\"enter\"\r\n        animate=\"center\"\r\n        exit=\"exit\"\r\n        custom={multiStep.direction}\r\n        {...restProps}\r\n      >\r\n        {children}\r\n      </motion.div>\r\n    </MultiStepperPartProvider>\r\n  );\r\n}\r\n\r\nexport function MultiStepPartForm({\r\n  form,\r\n  className,\r\n  children,\r\n  ...restProps\r\n}: React.ComponentProps<\"form\"> & {\r\n  // biome-ignore lint/suspicious/noExplicitAny: not needed\r\n  form: ReturnType<typeof useForm<any>>;\r\n}) {\r\n  const multiStep = useMultiStepper();\r\n  const thisPart = useMultiStepperPart();\r\n\r\n  return (\r\n    <Form {...form}>\r\n      <form\r\n        id={thisPart.id}\r\n        className={cn(\"space-y-4\", className)}\r\n        onSubmit={form.handleSubmit((value) => {\r\n          // multiStep.storeStep(thisPart.id, value);\r\n          // multiStep.next();\r\n        })}\r\n        {...restProps}\r\n      >\r\n        {children}\r\n      </form>\r\n    </Form>\r\n  );\r\n}\r\n\r\nexport function MultiStepFooter() {\r\n  const multiStep = useMultiStepper();\r\n\r\n  return (\r\n    <div className=\"flex items-center gap-2 justify-end\">\r\n      {multiStep.controls.hasPrevious() && (\r\n        <Button\r\n          type=\"button\"\r\n          variant=\"secondary\"\r\n          onClick={() => multiStep.controls.back()}\r\n        >\r\n          <ArrowLeftIcon />\r\n          Back\r\n        </Button>\r\n      )}\r\n      {multiStep.controls.hasNext() ? (\r\n        <Button type=\"submit\" form={multiStep.controls.part().id}>\r\n          Next\r\n          <ArrowRightIcon />\r\n        </Button>\r\n      ) : (\r\n        <Button type=\"submit\" form={multiStep.controls.part().id}>\r\n          Finish\r\n          <ArrowRightIcon />\r\n        </Button>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "./src/registry/new-york/multi-stepper/multi-stepper.context.tsx",
      "content": "import React from \"react\";\r\nimport type {\r\n  InferMultiStepFormData,\r\n  MultiStep,\r\n  MultiStepPartArray,\r\n} from \"./multi-stepper\";\r\nimport type { MultiStepperControls } from \"./multi-stepper.controls\";\r\n\r\nexport interface MultiStepperContext<\r\n  TParts extends MultiStepPartArray = MultiStepPartArray,\r\n  TStep extends MultiStep<TParts> = MultiStep<TParts>\r\n> {\r\n  /** The current direction of the stepper. */\r\n  readonly direction: number;\r\n  readonly parts: TParts;\r\n  readonly step: MultiStep<TParts>;\r\n  readonly controls: MultiStepperControls<TParts>;\r\n\r\n  onComplete(data: InferMultiStepFormData<TParts, TStep>): void;\r\n}\r\n\r\nconst MultiStepperContext = React.createContext<MultiStepperContext | null>(\r\n  null\r\n);\r\n\r\nconst MultiStepperPartContext = React.createContext<\r\n  MultiStepPartArray[number] | null\r\n>(null);\r\n\r\nexport const MultiStepperProvider = MultiStepperContext.Provider;\r\n\r\nexport const MultiStepperPartProvider = MultiStepperPartContext.Provider;\r\n\r\nexport function useMultiStepper() {\r\n  const context = React.useContext(MultiStepperContext);\r\n  if (!context) throw new Error(\"Missing MultiStepperContext provider\");\r\n  return context;\r\n}\r\n\r\nexport function useMultiStepperPart<TParts extends MultiStepPartArray>() {\r\n  const context = React.useContext(MultiStepperPartContext) as\r\n    | TParts[number]\r\n    | null;\r\n  if (!context) throw new Error(\"Missing MultiStepperPartContext provider\");\r\n  return context;\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "./src/registry/new-york/multi-stepper/multi-stepper.controls.ts",
      "content": "import type { MultiStep, MultiStepPartArray } from \"./multi-stepper\";\r\n\r\nexport interface MultiStepperControls<TParts extends MultiStepPartArray> {\r\n  readonly parts: TParts;\r\n  readonly step: MultiStep<TParts>;\r\n\r\n  setStep(step: MultiStep<TParts>): void;\r\n  index(): number;\r\n  next(): boolean;\r\n  back(): boolean;\r\n  part(): TParts[number];\r\n  hasNext(): boolean;\r\n  hasPrevious(): boolean;\r\n}\r\n\r\nexport abstract class AbstractMultiStepperControls<\r\n  TParts extends MultiStepPartArray\r\n> {\r\n  readonly parts: TParts;\r\n  readonly step: MultiStep<TParts>;\r\n\r\n  constructor(parts: TParts, step: MultiStep<TParts>) {\r\n    this.parts = parts;\r\n    this.step = step;\r\n  }\r\n\r\n  abstract onFinish(): void;\r\n\r\n  abstract setStep(step: MultiStep<TParts>): void;\r\n\r\n  index(): number {\r\n    return this.parts.findIndex((p) => p.id === this.step);\r\n  }\r\n\r\n  next(): boolean {\r\n    const currentIndex = this.index();\r\n    if (currentIndex === -1) return false;\r\n    if (currentIndex >= this.parts.length - 1) {\r\n      this.onFinish();\r\n      return false;\r\n    }\r\n    this.setStep(this.parts[currentIndex + 1].id);\r\n    return true;\r\n  }\r\n\r\n  back(): boolean {\r\n    const currentIndex = this.index();\r\n    if (currentIndex <= 0) return false;\r\n    this.setStep(this.parts[currentIndex - 1].id);\r\n    return true;\r\n  }\r\n\r\n  part(): TParts[number] {\r\n    return this.parts[this.index()];\r\n  }\r\n\r\n  hasNext(): boolean {\r\n    return this.index() < this.parts.length - 1;\r\n  }\r\n\r\n  hasPrevious(): boolean {\r\n    return this.index() > 0;\r\n  }\r\n}\r\n\r\nexport class ObservableMultiStepperControls<\r\n  TParts extends MultiStepPartArray\r\n> extends AbstractMultiStepperControls<TParts> {\r\n  private _onStepChange: (step: MultiStep<TParts>) => void;\r\n  private _onFinish: () => void;\r\n\r\n  constructor({\r\n    parts,\r\n    step,\r\n    onStepChange,\r\n    onFinish,\r\n  }: Readonly<{\r\n    parts: TParts;\r\n    step: MultiStep<TParts>;\r\n    onStepChange: (\r\n      this: ObservableMultiStepperControls<TParts>,\r\n      step: MultiStep<TParts>\r\n    ) => void;\r\n    onFinish: (this: ObservableMultiStepperControls<TParts>) => void;\r\n  }>) {\r\n    super(parts, step);\r\n    this._onStepChange = onStepChange.bind(this);\r\n    this._onFinish = onFinish.bind(this);\r\n  }\r\n\r\n  setStep(step: MultiStep<TParts>): void {\r\n    this._onStepChange(step);\r\n  }\r\n\r\n  onFinish(): void {\r\n    this._onFinish();\r\n  }\r\n}\r\n",
      "type": "registry:lib"
    }
  ]
}