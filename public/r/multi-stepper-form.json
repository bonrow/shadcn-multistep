{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "multi-stepper-form",
  "type": "registry:block",
  "title": "Hello World",
  "description": "A simple hello world component.",
  "dependencies": [
    "zod@4.0.0",
    "react-hook-form@^7.65.0"
  ],
  "registryDependencies": [
    "button",
    "form"
  ],
  "files": [
    {
      "path": "./src/registry/new-york/multi-stepper/multi-stepper.tsx",
      "content": "\"use client\";\r\nimport { ArrowLeftIcon, ArrowRightIcon } from \"lucide-react\";\r\nimport { AnimatePresence, motion } from \"motion/react\";\r\nimport React from \"react\";\r\nimport type { z } from \"zod\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport {\r\n  type MultiStepperContext,\r\n  MultiStepperPartProvider,\r\n  MultiStepperProvider,\r\n  useMultiStepper,\r\n  useMultiStepperPartUnsafe,\r\n} from \"./multi-stepper.context\";\r\nimport { ObservableMultiStepperControls } from \"./multi-stepper.controls\";\r\n\r\n//! You should move these type helpers to a separate file if you plan to reuse them\r\n// biome-ignore lint/suspicious/noExplicitAny: needed for type helper\r\ntype UnionKeys<U> = U extends any ? keyof U : never;\r\ntype MergeUnionToObject<U> = {\r\n  [K in UnionKeys<U>]: K extends keyof U ? U[K] : never;\r\n};\r\n\r\n// biome-ignore lint/suspicious/noExplicitAny: not needed\r\nexport type OutputSchema = z.ZodType<any, Record<string, any>>;\r\n\r\n/** Readonly array with readonly parts (useful for freezed constants). */\r\n// biome-ignore lint/suspicious/noExplicitAny: needed for deep reference (render->part)\r\nexport type MultiStepPartArray = ReadonlyArray<Readonly<MultiStepPart<any>>>;\r\n\r\n/** Extracts a union of all the IDs in `TPart`. */\r\nexport type MultiStep<TParts extends MultiStepPartArray> = TParts[number][\"id\"];\r\n\r\n/** Infers the `output` of `TStep` in `TParts`, or returns `never`. */\r\nexport type InferMultiStepOutput<\r\n  TParts extends MultiStepPartArray,\r\n  TStep extends MultiStep<TParts>\r\n> = z.infer<Extract<TParts[number], { id: TStep }>[\"output\"]>;\r\n\r\n/** Data representation of a single **part** in a multi-stepper. */\r\nexport type MultiStepPart<\r\n  TOutput extends OutputSchema = OutputSchema,\r\n  TRenderArgs = MultiStepPartDefaultRenderProps<TOutput>\r\n> = {\r\n  id: string;\r\n  title: React.ReactNode;\r\n  output: TOutput;\r\n  icon?: React.ReactNode;\r\n  defaultValues?: (\r\n    data: Partial<z.infer<TOutput>>\r\n  ) => Partial<z.infer<TOutput>>;\r\n  render: React.FC<TRenderArgs>;\r\n};\r\n\r\nexport type MultiStepPartDefaultRenderProps<TOutput extends OutputSchema> = {\r\n  stepper: MultiStepperContext;\r\n  defaultValues: Partial<z.infer<TOutput>>;\r\n  part: MultiStepPart<TOutput>;\r\n};\r\n\r\n/** Extracts the merged result of all steps through forming an intersection. */\r\nexport type MultiStepperMergedResult<TParts extends MultiStepPartArray> =\r\n  MergeUnionToObject<z.infer<TParts[number][\"output\"]>>;\r\n\r\nexport type MultiStepperPartsResult<TParts extends MultiStepPartArray> = {\r\n  [K in MultiStep<TParts>]: InferMultiStepOutput<TParts, K>;\r\n};\r\n\r\nexport type MultiStepperCheckedResult<TParts extends MultiStepPartArray> = {\r\n  merged: MultiStepperMergedResult<TParts>;\r\n  parts: MultiStepperPartsResult<TParts>;\r\n};\r\n\r\nexport type MultiStepperUncheckedResult<TParts extends MultiStepPartArray> = {\r\n  merged: Partial<MultiStepperMergedResult<TParts>>;\r\n  parts: Partial<MultiStepperCheckedResult<TParts>[\"parts\"]>;\r\n};\r\n\r\n/** Type helper to define a multi step part with proper generics. */\r\nexport const defineMultiStepPart = <TOutput extends OutputSchema>(\r\n  part: MultiStepPart<TOutput>\r\n): MultiStepPart<TOutput> => part;\r\n\r\n/** [Framer Motion] used to animate the multi-step form */\r\nconst slideVariants = {\r\n  enter: (direction: number) => ({\r\n    position: \"absolute\",\r\n    x: direction > 0 ? \"100%\" : \"-100%\",\r\n  }),\r\n  center: {\r\n    position: \"relative\",\r\n    x: 0,\r\n    opacity: 1,\r\n    transition: { duration: 0.3 },\r\n  },\r\n  exit: (direction: number) => ({\r\n    position: \"absolute\",\r\n    x: direction < 0 ? \"100%\" : \"-100%\",\r\n    transition: { duration: 0.3 },\r\n  }),\r\n};\r\n\r\nexport function MultiStepper<TParts extends MultiStepPartArray>({\r\n  parts,\r\n  step,\r\n  defaultStep = parts[0]?.id,\r\n  onStepChange,\r\n  onFinish,\r\n  className,\r\n  ...restProps\r\n}: React.ComponentProps<\"section\"> & {\r\n  parts: TParts;\r\n  defaultStep?: MultiStep<TParts>;\r\n  step?: MultiStep<TParts>;\r\n  onStepChange?: (step: MultiStep<TParts>) => void;\r\n  onFinish?: (result: {\r\n    /** Returns the stepper's partial result with everything gathered. */\r\n    partial(): MultiStepperUncheckedResult<TParts>;\r\n    /** Returns the stepper's complete result and throws an error if it's not complete. */\r\n    complete(): MultiStepperCheckedResult<TParts>;\r\n  }) => void;\r\n}) {\r\n  const directionRef = React.useRef(0);\r\n  const [_step, _setStep] = React.useState(defaultStep);\r\n  const resultRef = React.useRef<Partial<MultiStepperUncheckedResult<TParts>>>(\r\n    {}\r\n  );\r\n\r\n  if (_step == null) throw new Error(\"MultiStepper requires at least one step\");\r\n\r\n  const onFinishRef = React.useRef(onFinish);\r\n  onFinishRef.current = onFinish;\r\n\r\n  const onStepChangeRef = React.useRef(onStepChange);\r\n  onStepChangeRef.current = onStepChange;\r\n\r\n  React.useEffect(() => {\r\n    if (step === undefined) return;\r\n    _setStep(step);\r\n  }, [step]);\r\n\r\n  const controls = React.useMemo(() => {\r\n    return new ObservableMultiStepperControls<TParts>({\r\n      parts,\r\n      step: _step,\r\n      onFinish() {\r\n        const res = resultRef.current;\r\n        onFinishRef.current?.({\r\n          partial: () => res as MultiStepperUncheckedResult<TParts>,\r\n          complete: () => {\r\n            const resultParts = res.parts;\r\n            if (!resultParts) throw new Error(\"No parts data available.\");\r\n            const notCompletePart = parts.find((p) => !(p.id in resultParts));\r\n            if (notCompletePart)\r\n              throw new Error(`Part \"${notCompletePart.id}\" is not complete.`);\r\n            return res as MultiStepperCheckedResult<TParts>;\r\n          },\r\n        });\r\n      },\r\n      onStepChange(newStep) {\r\n        const currentIndex = this.index();\r\n        const newIndex = this.parts.findIndex((p) => p.id === newStep);\r\n        if (newIndex === -1) throw new Error(\"Step not found in parts\");\r\n        directionRef.current = newIndex > currentIndex ? 1 : -1;\r\n        _setStep(newStep);\r\n        onStepChangeRef.current?.(newStep);\r\n      },\r\n    });\r\n  }, [parts, _step]);\r\n\r\n  return (\r\n    <MultiStepperProvider\r\n      value={{\r\n        parts,\r\n        step: _step,\r\n        direction: directionRef.current,\r\n        controls,\r\n        result: () => resultRef.current,\r\n        onComplete(data) {\r\n          const p = (resultRef.current.parts ??\r\n            {}) as MultiStepperUncheckedResult<TParts>[\"parts\"];\r\n          p[_step] = data;\r\n          resultRef.current.parts =\r\n            p as MultiStepperUncheckedResult<TParts>[\"parts\"];\r\n          resultRef.current.merged = {\r\n            ...resultRef.current.merged,\r\n            ...data,\r\n          };\r\n          //* Remove this if you don't want to auto-complete on last step submission\r\n          controls.next();\r\n        },\r\n      }}\r\n    >\r\n      <section\r\n        className={cn(\r\n          \"flex flex-col gap-6 overflow-hidden relative\",\r\n          className\r\n        )}\r\n        {...restProps}\r\n      />\r\n    </MultiStepperProvider>\r\n  );\r\n}\r\n\r\nexport function MultiStepperCurrentStep() {\r\n  const multiStep = useMultiStepper();\r\n\r\n  return (\r\n    <div className=\"relative\">\r\n      <AnimatePresence custom={multiStep.direction}>\r\n        {multiStep.parts.map((part) =>\r\n          part.id === multiStep.controls.step ? (\r\n            <MultiStepPart\r\n              parts={multiStep.parts}\r\n              step={part.id}\r\n              key={part.id}\r\n            />\r\n          ) : null\r\n        )}\r\n      </AnimatePresence>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction MultiStepPart<\r\n  TParts extends MultiStepPartArray,\r\n  TStep extends MultiStep<TParts>\r\n>({\r\n  parts,\r\n  step,\r\n  children,\r\n  className,\r\n  ...restProps\r\n}: React.ComponentProps<typeof motion.div> & {\r\n  parts: TParts;\r\n  step: TStep;\r\n}) {\r\n  const multiStep = useMultiStepper();\r\n\r\n  const part = parts.find((s) => s.id === step);\r\n  if (!part) throw new Error(`Step with id \"${step}\" does not exist.`);\r\n\r\n  const defaultValues = part.defaultValues\r\n    ? part.defaultValues(multiStep.result().parts?.[part.id] ?? {})\r\n    : {};\r\n\r\n  return (\r\n    <MultiStepperPartProvider value={part}>\r\n      <motion.div\r\n        key={part.id}\r\n        variants={slideVariants}\r\n        initial=\"enter\"\r\n        animate=\"center\"\r\n        exit=\"exit\"\r\n        custom={multiStep.direction}\r\n        className={cn(\"relative w-full\", className)}\r\n        {...restProps}\r\n      >\r\n        <part.render\r\n          stepper={multiStep}\r\n          defaultValues={defaultValues}\r\n          part={part}\r\n        />\r\n      </motion.div>\r\n    </MultiStepperPartProvider>\r\n  );\r\n}\r\n\r\nexport function MultiStepperTitle({\r\n  className,\r\n  children,\r\n  ...restProps\r\n}: React.ComponentProps<\"h3\">) {\r\n  const multiStepper = useMultiStepper();\r\n  const singleStep = useMultiStepperPartUnsafe();\r\n\r\n  // If this title is used within a part, use that part here, otherwise\r\n  // use the current active step (used within MultiStepper directly).\r\n  // This is useful to allow for titles to be used within steps to have them\r\n  // within the animation (which may be accessible though!).\r\n  const current = singleStep?.id ?? multiStepper.controls.step;\r\n  const part = multiStepper.controls.parts.find((p) => p.id === current);\r\n\r\n  if (!part) throw new Error(\"MultiStepperTitle must be used within a step\");\r\n\r\n  return (\r\n    <h3\r\n      className={cn(\"text-lg font-medium flex items-center gap-2\", className)}\r\n      {...restProps}\r\n    >\r\n      {children}\r\n      {part.icon}\r\n      <span>{part.title}</span>\r\n    </h3>\r\n  );\r\n}\r\n\r\nexport function MultiStepperFooter({\r\n  className,\r\n  ...restProps\r\n}: Omit<React.ComponentProps<\"div\">, \"children\">) {\r\n  const multiStep = useMultiStepper();\r\n\r\n  return (\r\n    <div\r\n      className={cn(\r\n        \"flex items-center gap-2 justify-end *:not-disabled:cursor-pointer\",\r\n        className\r\n      )}\r\n      {...restProps}\r\n    >\r\n      {multiStep.controls.hasPrevious() && (\r\n        <Button\r\n          type=\"button\"\r\n          variant=\"secondary\"\r\n          onClick={() => multiStep.controls.back()}\r\n        >\r\n          <ArrowLeftIcon />\r\n          Back\r\n        </Button>\r\n      )}\r\n      {multiStep.controls.hasNext() ? (\r\n        <Button type=\"submit\" form={multiStep.controls.part().id}>\r\n          Next\r\n          <ArrowRightIcon />\r\n        </Button>\r\n      ) : (\r\n        <Button type=\"submit\" form={multiStep.controls.part().id}>\r\n          Complete\r\n          <ArrowRightIcon />\r\n        </Button>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "./src/registry/new-york/multi-stepper/multi-stepper.context.tsx",
      "content": "import React from \"react\";\r\nimport type {\r\n  InferMultiStepOutput,\r\n  MultiStep,\r\n  MultiStepPartArray,\r\n  MultiStepperUncheckedResult,\r\n} from \"./multi-stepper\";\r\nimport type { MultiStepperControls } from \"./multi-stepper.controls\";\r\n\r\nexport interface MultiStepperContext<\r\n  TParts extends MultiStepPartArray = MultiStepPartArray,\r\n  TStep extends MultiStep<TParts> = MultiStep<TParts>\r\n> {\r\n  /** The current direction of the stepper. */\r\n  readonly direction: number;\r\n  readonly parts: TParts;\r\n  readonly step: MultiStep<TParts>;\r\n  readonly controls: MultiStepperControls<TParts>;\r\n  readonly result: () => Partial<MultiStepperUncheckedResult<TParts>>;\r\n\r\n  onComplete(data: InferMultiStepOutput<TParts, TStep>): void;\r\n}\r\n\r\nconst MultiStepperContext = React.createContext<MultiStepperContext | null>(\r\n  null\r\n);\r\n\r\nconst MultiStepperPartContext = React.createContext<\r\n  MultiStepPartArray[number] | null\r\n>(null);\r\n\r\nexport const MultiStepperProvider = MultiStepperContext.Provider;\r\n\r\nexport const MultiStepperPartProvider = MultiStepperPartContext.Provider;\r\n\r\nexport function useMultiStepper() {\r\n  const context = React.useContext(MultiStepperContext);\r\n  if (!context) throw new Error(\"Missing MultiStepperContext provider\");\r\n  return context;\r\n}\r\n\r\nexport function useMultiStepperPart<TParts extends MultiStepPartArray>() {\r\n  const context = React.useContext(MultiStepperPartContext) as\r\n    | TParts[number]\r\n    | null;\r\n  if (!context) throw new Error(\"Missing MultiStepperPartContext provider\");\r\n  return context;\r\n}\r\n\r\nexport const useMultiStepperPartUnsafe = () =>\r\n  React.useContext(MultiStepperPartContext);\r\n",
      "type": "registry:component"
    },
    {
      "path": "./src/registry/new-york/multi-stepper/multi-stepper.controls.ts",
      "content": "import type { MultiStep, MultiStepPartArray } from \"./multi-stepper\";\r\n\r\nexport interface MultiStepperControls<TParts extends MultiStepPartArray> {\r\n  readonly parts: TParts;\r\n  readonly step: MultiStep<TParts>;\r\n\r\n  setStep(step: MultiStep<TParts>): void;\r\n  index(): number;\r\n  next(): boolean;\r\n  back(): boolean;\r\n  part(): TParts[number];\r\n  hasNext(): boolean;\r\n  hasPrevious(): boolean;\r\n}\r\n\r\nexport abstract class AbstractMultiStepperControls<\r\n  TParts extends MultiStepPartArray\r\n> {\r\n  readonly parts: TParts;\r\n  readonly step: MultiStep<TParts>;\r\n\r\n  constructor(parts: TParts, step: MultiStep<TParts>) {\r\n    this.parts = parts;\r\n    this.step = step;\r\n  }\r\n\r\n  abstract onFinish(): void;\r\n\r\n  abstract setStep(step: MultiStep<TParts>): void;\r\n\r\n  index(): number {\r\n    return this.parts.findIndex((p) => p.id === this.step);\r\n  }\r\n\r\n  next(): boolean {\r\n    const currentIndex = this.index();\r\n    if (currentIndex === -1) return false;\r\n    if (currentIndex >= this.parts.length - 1) {\r\n      this.onFinish();\r\n      return false;\r\n    }\r\n    this.setStep(this.parts[currentIndex + 1].id);\r\n    return true;\r\n  }\r\n\r\n  back(): boolean {\r\n    const currentIndex = this.index();\r\n    if (currentIndex <= 0) return false;\r\n    this.setStep(this.parts[currentIndex - 1].id);\r\n    return true;\r\n  }\r\n\r\n  part(): TParts[number] {\r\n    return this.parts[this.index()];\r\n  }\r\n\r\n  hasNext(): boolean {\r\n    return this.index() < this.parts.length - 1;\r\n  }\r\n\r\n  hasPrevious(): boolean {\r\n    return this.index() > 0;\r\n  }\r\n}\r\n\r\nexport class ObservableMultiStepperControls<\r\n  TParts extends MultiStepPartArray\r\n> extends AbstractMultiStepperControls<TParts> {\r\n  private _onStepChange: (step: MultiStep<TParts>) => void;\r\n  private _onFinish: () => void;\r\n\r\n  constructor({\r\n    parts,\r\n    step,\r\n    onStepChange,\r\n    onFinish,\r\n  }: Readonly<{\r\n    parts: TParts;\r\n    step: MultiStep<TParts>;\r\n    onStepChange: (\r\n      this: ObservableMultiStepperControls<TParts>,\r\n      step: MultiStep<TParts>\r\n    ) => void;\r\n    onFinish: (this: ObservableMultiStepperControls<TParts>) => void;\r\n  }>) {\r\n    super(parts, step);\r\n    this._onStepChange = onStepChange.bind(this);\r\n    this._onFinish = onFinish.bind(this);\r\n  }\r\n\r\n  setStep(step: MultiStep<TParts>): void {\r\n    this._onStepChange(step);\r\n  }\r\n\r\n  onFinish(): void {\r\n    this._onFinish();\r\n  }\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "./src/registry/new-york/multi-stepper/multi-stepper.form.tsx",
      "content": "import { zodResolver } from \"@hookform/resolvers/zod\";\r\nimport type React from \"react\";\r\nimport { type DefaultValues, useForm } from \"react-hook-form\";\r\nimport type z from \"zod\";\r\nimport { Form } from \"@/components/ui/form\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport type {\r\n  MultiStepPart,\r\n  MultiStepPartDefaultRenderProps,\r\n  OutputSchema,\r\n} from \"./multi-stepper\";\r\nimport { useMultiStepper, useMultiStepperPart } from \"./multi-stepper.context\";\r\n\r\nexport type MultiStepPartFormRenderProps<TOutput extends OutputSchema> =\r\n  MultiStepPartDefaultRenderProps<TOutput> & {\r\n    form: ReturnType<typeof useForm<z.infer<TOutput>>>;\r\n  };\r\n\r\n/** Type helper to define a multi step part with proper generics. */\r\nexport function defineMultiStepFormPart<TOutput extends OutputSchema>({\r\n  render: RenderComposed,\r\n  ...restPart\r\n}: Omit<MultiStepPart<TOutput>, \"render\"> & {\r\n  render: React.FC<MultiStepPartFormRenderProps<TOutput>>;\r\n}): MultiStepPart<TOutput> {\r\n  return {\r\n    ...restPart,\r\n    render: ({ defaultValues, ...rest }) => {\r\n      // biome-ignore lint/suspicious/noExplicitAny: too complex\r\n      const form = useForm<any>({\r\n        resolver: zodResolver(rest.part.output),\r\n        defaultValues: defaultValues as DefaultValues<typeof defaultValues>,\r\n      });\r\n      return (\r\n        <MultiStepperPartForm form={form}>\r\n          <RenderComposed form={form} defaultValues={defaultValues} {...rest} />\r\n        </MultiStepperPartForm>\r\n      );\r\n    },\r\n  };\r\n}\r\n\r\nexport function MultiStepperPartForm({\r\n  className,\r\n  children,\r\n  form,\r\n  ...restProps\r\n}: React.ComponentProps<\"form\"> & {\r\n  form: ReturnType<typeof useForm>;\r\n}) {\r\n  const multiStep = useMultiStepper();\r\n  const thisPart = useMultiStepperPart();\r\n\r\n  return (\r\n    <Form {...form}>\r\n      <form\r\n        id={thisPart.id}\r\n        className={cn(\"space-y-4\", className)}\r\n        onSubmit={form.handleSubmit(multiStep.onComplete)}\r\n        {...restProps}\r\n      >\r\n        {children}\r\n      </form>\r\n    </Form>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    }
  ]
}